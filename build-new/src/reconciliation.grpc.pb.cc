// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: reconciliation.proto

#include "reconciliation.pb.h"
#include "reconciliation.grpc.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/channel_interface.h>
#include <grpcpp/impl/codegen/client_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/rpc_service_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/sync_stream.h>
namespace reconciliation {

static const char* Estimation_method_names[] = {
  "/reconciliation.Estimation/Estimate",
  "/reconciliation.Estimation/ReconcileSetUp",
  "/reconciliation.Estimation/ReconcilePinSketch",
  "/reconciliation.Estimation/ReconcileDDigest",
  "/reconciliation.Estimation/ReconcileGraphene",
  "/reconciliation.Estimation/ReconcileParityBitmapSketch",
  "/reconciliation.Estimation/Synchronize",
};

std::unique_ptr< Estimation::Stub> Estimation::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< Estimation::Stub> stub(new Estimation::Stub(channel));
  return stub;
}

Estimation::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel)
  : channel_(channel), rpcmethod_Estimate_(Estimation_method_names[0], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_ReconcileSetUp_(Estimation_method_names[1], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_ReconcilePinSketch_(Estimation_method_names[2], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_ReconcileDDigest_(Estimation_method_names[3], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_ReconcileGraphene_(Estimation_method_names[4], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_ReconcileParityBitmapSketch_(Estimation_method_names[5], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_Synchronize_(Estimation_method_names[6], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status Estimation::Stub::Estimate(::grpc::ClientContext* context, const ::reconciliation::EstimateRequest& request, ::reconciliation::EstimateReply* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_Estimate_, context, request, response);
}

void Estimation::Stub::experimental_async::Estimate(::grpc::ClientContext* context, const ::reconciliation::EstimateRequest* request, ::reconciliation::EstimateReply* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Estimate_, context, request, response, std::move(f));
}

void Estimation::Stub::experimental_async::Estimate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::reconciliation::EstimateReply* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Estimate_, context, request, response, std::move(f));
}

void Estimation::Stub::experimental_async::Estimate(::grpc::ClientContext* context, const ::reconciliation::EstimateRequest* request, ::reconciliation::EstimateReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_Estimate_, context, request, response, reactor);
}

void Estimation::Stub::experimental_async::Estimate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::reconciliation::EstimateReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_Estimate_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::reconciliation::EstimateReply>* Estimation::Stub::AsyncEstimateRaw(::grpc::ClientContext* context, const ::reconciliation::EstimateRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::reconciliation::EstimateReply>::Create(channel_.get(), cq, rpcmethod_Estimate_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::reconciliation::EstimateReply>* Estimation::Stub::PrepareAsyncEstimateRaw(::grpc::ClientContext* context, const ::reconciliation::EstimateRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::reconciliation::EstimateReply>::Create(channel_.get(), cq, rpcmethod_Estimate_, context, request, false);
}

::grpc::Status Estimation::Stub::ReconcileSetUp(::grpc::ClientContext* context, const ::reconciliation::SetUpRequest& request, ::reconciliation::SetUpReply* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_ReconcileSetUp_, context, request, response);
}

void Estimation::Stub::experimental_async::ReconcileSetUp(::grpc::ClientContext* context, const ::reconciliation::SetUpRequest* request, ::reconciliation::SetUpReply* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_ReconcileSetUp_, context, request, response, std::move(f));
}

void Estimation::Stub::experimental_async::ReconcileSetUp(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::reconciliation::SetUpReply* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_ReconcileSetUp_, context, request, response, std::move(f));
}

void Estimation::Stub::experimental_async::ReconcileSetUp(::grpc::ClientContext* context, const ::reconciliation::SetUpRequest* request, ::reconciliation::SetUpReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_ReconcileSetUp_, context, request, response, reactor);
}

void Estimation::Stub::experimental_async::ReconcileSetUp(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::reconciliation::SetUpReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_ReconcileSetUp_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::reconciliation::SetUpReply>* Estimation::Stub::AsyncReconcileSetUpRaw(::grpc::ClientContext* context, const ::reconciliation::SetUpRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::reconciliation::SetUpReply>::Create(channel_.get(), cq, rpcmethod_ReconcileSetUp_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::reconciliation::SetUpReply>* Estimation::Stub::PrepareAsyncReconcileSetUpRaw(::grpc::ClientContext* context, const ::reconciliation::SetUpRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::reconciliation::SetUpReply>::Create(channel_.get(), cq, rpcmethod_ReconcileSetUp_, context, request, false);
}

::grpc::Status Estimation::Stub::ReconcilePinSketch(::grpc::ClientContext* context, const ::reconciliation::PinSketchRequest& request, ::reconciliation::PinSketchReply* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_ReconcilePinSketch_, context, request, response);
}

void Estimation::Stub::experimental_async::ReconcilePinSketch(::grpc::ClientContext* context, const ::reconciliation::PinSketchRequest* request, ::reconciliation::PinSketchReply* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_ReconcilePinSketch_, context, request, response, std::move(f));
}

void Estimation::Stub::experimental_async::ReconcilePinSketch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::reconciliation::PinSketchReply* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_ReconcilePinSketch_, context, request, response, std::move(f));
}

void Estimation::Stub::experimental_async::ReconcilePinSketch(::grpc::ClientContext* context, const ::reconciliation::PinSketchRequest* request, ::reconciliation::PinSketchReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_ReconcilePinSketch_, context, request, response, reactor);
}

void Estimation::Stub::experimental_async::ReconcilePinSketch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::reconciliation::PinSketchReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_ReconcilePinSketch_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::reconciliation::PinSketchReply>* Estimation::Stub::AsyncReconcilePinSketchRaw(::grpc::ClientContext* context, const ::reconciliation::PinSketchRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::reconciliation::PinSketchReply>::Create(channel_.get(), cq, rpcmethod_ReconcilePinSketch_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::reconciliation::PinSketchReply>* Estimation::Stub::PrepareAsyncReconcilePinSketchRaw(::grpc::ClientContext* context, const ::reconciliation::PinSketchRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::reconciliation::PinSketchReply>::Create(channel_.get(), cq, rpcmethod_ReconcilePinSketch_, context, request, false);
}

::grpc::Status Estimation::Stub::ReconcileDDigest(::grpc::ClientContext* context, const ::reconciliation::DDigestRequest& request, ::reconciliation::DDigestReply* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_ReconcileDDigest_, context, request, response);
}

void Estimation::Stub::experimental_async::ReconcileDDigest(::grpc::ClientContext* context, const ::reconciliation::DDigestRequest* request, ::reconciliation::DDigestReply* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_ReconcileDDigest_, context, request, response, std::move(f));
}

void Estimation::Stub::experimental_async::ReconcileDDigest(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::reconciliation::DDigestReply* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_ReconcileDDigest_, context, request, response, std::move(f));
}

void Estimation::Stub::experimental_async::ReconcileDDigest(::grpc::ClientContext* context, const ::reconciliation::DDigestRequest* request, ::reconciliation::DDigestReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_ReconcileDDigest_, context, request, response, reactor);
}

void Estimation::Stub::experimental_async::ReconcileDDigest(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::reconciliation::DDigestReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_ReconcileDDigest_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::reconciliation::DDigestReply>* Estimation::Stub::AsyncReconcileDDigestRaw(::grpc::ClientContext* context, const ::reconciliation::DDigestRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::reconciliation::DDigestReply>::Create(channel_.get(), cq, rpcmethod_ReconcileDDigest_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::reconciliation::DDigestReply>* Estimation::Stub::PrepareAsyncReconcileDDigestRaw(::grpc::ClientContext* context, const ::reconciliation::DDigestRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::reconciliation::DDigestReply>::Create(channel_.get(), cq, rpcmethod_ReconcileDDigest_, context, request, false);
}

::grpc::Status Estimation::Stub::ReconcileGraphene(::grpc::ClientContext* context, const ::reconciliation::GrapheneRequest& request, ::reconciliation::GrapheneReply* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_ReconcileGraphene_, context, request, response);
}

void Estimation::Stub::experimental_async::ReconcileGraphene(::grpc::ClientContext* context, const ::reconciliation::GrapheneRequest* request, ::reconciliation::GrapheneReply* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_ReconcileGraphene_, context, request, response, std::move(f));
}

void Estimation::Stub::experimental_async::ReconcileGraphene(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::reconciliation::GrapheneReply* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_ReconcileGraphene_, context, request, response, std::move(f));
}

void Estimation::Stub::experimental_async::ReconcileGraphene(::grpc::ClientContext* context, const ::reconciliation::GrapheneRequest* request, ::reconciliation::GrapheneReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_ReconcileGraphene_, context, request, response, reactor);
}

void Estimation::Stub::experimental_async::ReconcileGraphene(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::reconciliation::GrapheneReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_ReconcileGraphene_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::reconciliation::GrapheneReply>* Estimation::Stub::AsyncReconcileGrapheneRaw(::grpc::ClientContext* context, const ::reconciliation::GrapheneRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::reconciliation::GrapheneReply>::Create(channel_.get(), cq, rpcmethod_ReconcileGraphene_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::reconciliation::GrapheneReply>* Estimation::Stub::PrepareAsyncReconcileGrapheneRaw(::grpc::ClientContext* context, const ::reconciliation::GrapheneRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::reconciliation::GrapheneReply>::Create(channel_.get(), cq, rpcmethod_ReconcileGraphene_, context, request, false);
}

::grpc::Status Estimation::Stub::ReconcileParityBitmapSketch(::grpc::ClientContext* context, const ::reconciliation::PbsRequest& request, ::reconciliation::PbsReply* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_ReconcileParityBitmapSketch_, context, request, response);
}

void Estimation::Stub::experimental_async::ReconcileParityBitmapSketch(::grpc::ClientContext* context, const ::reconciliation::PbsRequest* request, ::reconciliation::PbsReply* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_ReconcileParityBitmapSketch_, context, request, response, std::move(f));
}

void Estimation::Stub::experimental_async::ReconcileParityBitmapSketch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::reconciliation::PbsReply* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_ReconcileParityBitmapSketch_, context, request, response, std::move(f));
}

void Estimation::Stub::experimental_async::ReconcileParityBitmapSketch(::grpc::ClientContext* context, const ::reconciliation::PbsRequest* request, ::reconciliation::PbsReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_ReconcileParityBitmapSketch_, context, request, response, reactor);
}

void Estimation::Stub::experimental_async::ReconcileParityBitmapSketch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::reconciliation::PbsReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_ReconcileParityBitmapSketch_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::reconciliation::PbsReply>* Estimation::Stub::AsyncReconcileParityBitmapSketchRaw(::grpc::ClientContext* context, const ::reconciliation::PbsRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::reconciliation::PbsReply>::Create(channel_.get(), cq, rpcmethod_ReconcileParityBitmapSketch_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::reconciliation::PbsReply>* Estimation::Stub::PrepareAsyncReconcileParityBitmapSketchRaw(::grpc::ClientContext* context, const ::reconciliation::PbsRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::reconciliation::PbsReply>::Create(channel_.get(), cq, rpcmethod_ReconcileParityBitmapSketch_, context, request, false);
}

::grpc::Status Estimation::Stub::Synchronize(::grpc::ClientContext* context, const ::reconciliation::SynchronizeMessage& request, ::reconciliation::SynchronizeMessage* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_Synchronize_, context, request, response);
}

void Estimation::Stub::experimental_async::Synchronize(::grpc::ClientContext* context, const ::reconciliation::SynchronizeMessage* request, ::reconciliation::SynchronizeMessage* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Synchronize_, context, request, response, std::move(f));
}

void Estimation::Stub::experimental_async::Synchronize(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::reconciliation::SynchronizeMessage* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Synchronize_, context, request, response, std::move(f));
}

void Estimation::Stub::experimental_async::Synchronize(::grpc::ClientContext* context, const ::reconciliation::SynchronizeMessage* request, ::reconciliation::SynchronizeMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_Synchronize_, context, request, response, reactor);
}

void Estimation::Stub::experimental_async::Synchronize(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::reconciliation::SynchronizeMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_Synchronize_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::reconciliation::SynchronizeMessage>* Estimation::Stub::AsyncSynchronizeRaw(::grpc::ClientContext* context, const ::reconciliation::SynchronizeMessage& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::reconciliation::SynchronizeMessage>::Create(channel_.get(), cq, rpcmethod_Synchronize_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::reconciliation::SynchronizeMessage>* Estimation::Stub::PrepareAsyncSynchronizeRaw(::grpc::ClientContext* context, const ::reconciliation::SynchronizeMessage& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::reconciliation::SynchronizeMessage>::Create(channel_.get(), cq, rpcmethod_Synchronize_, context, request, false);
}

Estimation::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Estimation_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Estimation::Service, ::reconciliation::EstimateRequest, ::reconciliation::EstimateReply>(
          [](Estimation::Service* service,
             ::grpc_impl::ServerContext* ctx,
             const ::reconciliation::EstimateRequest* req,
             ::reconciliation::EstimateReply* resp) {
               return service->Estimate(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Estimation_method_names[1],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Estimation::Service, ::reconciliation::SetUpRequest, ::reconciliation::SetUpReply>(
          [](Estimation::Service* service,
             ::grpc_impl::ServerContext* ctx,
             const ::reconciliation::SetUpRequest* req,
             ::reconciliation::SetUpReply* resp) {
               return service->ReconcileSetUp(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Estimation_method_names[2],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Estimation::Service, ::reconciliation::PinSketchRequest, ::reconciliation::PinSketchReply>(
          [](Estimation::Service* service,
             ::grpc_impl::ServerContext* ctx,
             const ::reconciliation::PinSketchRequest* req,
             ::reconciliation::PinSketchReply* resp) {
               return service->ReconcilePinSketch(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Estimation_method_names[3],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Estimation::Service, ::reconciliation::DDigestRequest, ::reconciliation::DDigestReply>(
          [](Estimation::Service* service,
             ::grpc_impl::ServerContext* ctx,
             const ::reconciliation::DDigestRequest* req,
             ::reconciliation::DDigestReply* resp) {
               return service->ReconcileDDigest(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Estimation_method_names[4],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Estimation::Service, ::reconciliation::GrapheneRequest, ::reconciliation::GrapheneReply>(
          [](Estimation::Service* service,
             ::grpc_impl::ServerContext* ctx,
             const ::reconciliation::GrapheneRequest* req,
             ::reconciliation::GrapheneReply* resp) {
               return service->ReconcileGraphene(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Estimation_method_names[5],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Estimation::Service, ::reconciliation::PbsRequest, ::reconciliation::PbsReply>(
          [](Estimation::Service* service,
             ::grpc_impl::ServerContext* ctx,
             const ::reconciliation::PbsRequest* req,
             ::reconciliation::PbsReply* resp) {
               return service->ReconcileParityBitmapSketch(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Estimation_method_names[6],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Estimation::Service, ::reconciliation::SynchronizeMessage, ::reconciliation::SynchronizeMessage>(
          [](Estimation::Service* service,
             ::grpc_impl::ServerContext* ctx,
             const ::reconciliation::SynchronizeMessage* req,
             ::reconciliation::SynchronizeMessage* resp) {
               return service->Synchronize(ctx, req, resp);
             }, this)));
}

Estimation::Service::~Service() {
}

::grpc::Status Estimation::Service::Estimate(::grpc::ServerContext* context, const ::reconciliation::EstimateRequest* request, ::reconciliation::EstimateReply* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Estimation::Service::ReconcileSetUp(::grpc::ServerContext* context, const ::reconciliation::SetUpRequest* request, ::reconciliation::SetUpReply* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Estimation::Service::ReconcilePinSketch(::grpc::ServerContext* context, const ::reconciliation::PinSketchRequest* request, ::reconciliation::PinSketchReply* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Estimation::Service::ReconcileDDigest(::grpc::ServerContext* context, const ::reconciliation::DDigestRequest* request, ::reconciliation::DDigestReply* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Estimation::Service::ReconcileGraphene(::grpc::ServerContext* context, const ::reconciliation::GrapheneRequest* request, ::reconciliation::GrapheneReply* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Estimation::Service::ReconcileParityBitmapSketch(::grpc::ServerContext* context, const ::reconciliation::PbsRequest* request, ::reconciliation::PbsReply* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Estimation::Service::Synchronize(::grpc::ServerContext* context, const ::reconciliation::SynchronizeMessage* request, ::reconciliation::SynchronizeMessage* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


}  // namespace reconciliation

